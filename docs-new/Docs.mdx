## Guides

### Routing

> :warning: We recommend reading the [Vue Tour](#vue-tour) or [React Tour](#react-tour) before proceeding with guides.

 - [Filesystem Routing VS Route Strings VS Route Functions](#filesystem-routing-vs-route-strings-vs-route-functions)
 - [Server-side Routing VS Client-side Routing](#server-side-routing-vs-client-side-routing)
 - [Active Links `<a class="is-active">`](#active-links-a-classis-active)
 - [Nested Routes](#nested-routes)

<br/>

#### Filesystem Routing VS Route Strings VS Route Functions

If a page doesn't have a `.page.route.js` file then `vite-plugin-ssr` uses Filesystem Routing:

```
FILESYSTEM                  URL
pages/index.page.js         /
pages/about.page.js         /about
pages/faq/index.page.js     /faq
```

To define a parameterized route, or for more control, you can `export default` a Route String in `.page.route.js`.

```
// /pages/product.page.route.js

export default '/product/:productId'
```

The `productId` value is available at `pageContext.routeParams.productId` so that you can fetch data in `async addPageContext(pageContext)` which is explained at [Data Fetching](#data-fetching).

For full programmatic flexibility, you can define a Route Function.

```js
// /pages/admin.page.route.js

// Route Functions allow us to implement advanced routing such as route guards.
export default (pageContext) => {
  const { url } = pageContext
  if (url === '/admin' && pageContext.user.isAdmin) {
    return { match: true }
  }
}
```

For detailed informations about Filesystem Routing, Route Strings, and Route Functions:
 - [API - Filesystem Routing](#filesystem-routing)
 - [API - `*.page.route.js`](#pageroutejs)
 - [API - Route String](#route-string)
 - [API - Route Function](#route-function)

<br/>

#### Server-side Routing VS Client-side Routing

You can choose between two routing strategy:
 - Server-side Routing (for simpler architecture)
 - Client-side Routing (for faster and animated page transitions)

You can also use a routing library such as Vue Router and React Router (in complete replacement or in combination). Examples:
 - [/examples/vue-router/](examples/vue-router/)
 - [/examples/react-router/](examples/react-router/)

By default, `vite-plugin-ssr` does Server-side Routing,
which is the "old school" way of doing routing: when the user changes the page,
a new HTML request is made, and the old page (i.e. its HTML) is completely replaced with the new page.

If you don't have a strong rationale for doing something differently, then stick to Server-side Routing as it leads to a simpler app architecture.

That said, `vite-plugin-ssr` has first-class support for Client-side Routing and you can opt-in by using `useClientRouter()`:
 - [`import { useClientRouter } from 'vite-plugin-ssr/client/router'`](#import--useClientRouter--from-vite-plugin-ssrclientrouter)

With Client-side Routing,
instead of doing a full HTML reload,
only the DOM is updated:
the new page's root (Vue/React/...) component is loaded and the view framework (Vue/React/...)
renders the new root component to the DOM.

Client-side Routing enables:
- Slightly faster page transitions.
- Custom animated page transitions.

But Client-side Routing leads to an inherently more complex app architecture,
which is why we recommend using Client-side Routing only if you
have a strong rationale.

<br/>

#### Active Links `<a class="is-active">`

Pass `pageContext.urlPathname` (available on both the client and the server)
[to your link component](#pass-pagecontext-to-anyall-components).
You can then set `isActive = href===urlPathname` in your link component.

<br/>

#### Nested Routes

A nested route (aka sub route) is, essentially, when you have a route with multiple parameters,
for example `/product/:productId/:productView`.

```
URL                        productId     productView
/product/1337              1337          null
/product/1337/pricing      1337          pricing
/product/42/reviews        42            reviews
```

With `vite-plugin-ssr`, we can define a Route String that has multiple parameters.

```js
// product.page.route.js

export default `/product/:productId/:productView`
```

```js
// product.page.route.js

// We can also use a Route Function
export default (pageContext) => {
  const { url } = pageContext
  if (! url.startsWith('/product/')) return false
  const [productId, productView] = url.split('/').slice(2)
  return { match: true, routeParams: { productId, productView } }
}
```

Usually, the sub route is used for navigating some (deeply) nested view:

```
/product/42/pricing                   /product/42/reviews
+------------------+                  +-----------------+
| Product          |                  | Product         |
| +--------------+ |                  | +-------------+ |
| | Pricing      | |  +------------>  | | Reviews     | |
| |              | |                  | |             | |
| +--------------+ |                  | +-------------+ |
+------------------+                  +-----------------+
```

> :warning: If your sub routes don't need URLs (if it's fine that the Product Pricing and the Product Reviews share the same URL `/product/42`), then you can simply use a stateful component instead. (When the user clicks on a "pricing" link => the stateful component changes its internal state `productView` to `'pricing'` to show the pricing view.)

By default,
`vite-plugin-ssr` does [Server-side Routing](#server-side-routing-vs-client-side-routing),
which means that when the user navigates from `/product/42/pricing` to `/product/42/reviews`,
the old page (i.e. the HTML of) `/product/42/pricing` is fully replaced with the new page (i.e. the HTML of) `/product/42/reviews`,
leading to a jittery experience.

For smoother navigations, we can use [Client-side Routing](#import--useClientRouter--from-vite-plugin-ssrclientrouter).

```js
// product.page.client.js

import { useClientRouter } from 'vite-plugin-ssr/client/router'

// We use Client-side Routing so that, when the user navigates from `/product/42/pricing`
// to `/product/42/reviews`, only the relevant (deeply) nested view is updated (instead of
// a full HTML reload).

// Note that we override `_default.page.client.js`. This means all our other pages can use
// Server-side Routing while this page uses Client-side Routing.
// (If we are already using `useClientRouter()` in `_default.page.client.js`, then we don't need to
// create this `product.page.client.js` file.)

useClientRouter({
  render(pageContext) {
    /* ... */
  }
})
```

We can then use `<a href="/product/42/reviews" keep-scroll-position />` / `navigate('/product/42/reviews', { keepScrollPosition: true })` to avoid the browser to scroll to the top upon navigation.

We can also [pass `pageContext.routeParams` to any/all components](#pass-pagecontext-to-anyall-components),
so that we can navigate/render the routed nested view.

Alternatively,
we can use a Route String Wildcard (e.g. `/product/:params*`) and then use a routing library (Vue Router, React Router, ...) for that page,
but we recommend the aforementioned solution instead as it is usually simpler.

<br/><br/>


<h3 title-addendum="SSG">Pre-rendering</h3>

> :warning: We recommend reading the [Vue Tour](#vue-tour) or [React Tour](#react-tour) before proceeding with guides.

> :asterisk: **What is pre-rendering?**
> Pre-rendering means to render the HTML of all your pages at build-time:
> normally the HTML of a page is rendered at request-time
> (when your user navigates to that page), but
> with pre-rendering the HTML of a page is rendered at build-time instead.
> Your app then consists only of static files (HTML, JS, CSS, images, ...)
> that you can deploy to so-called "static hosts" such as [GitHub Pages](https://pages.github.com/), [Cloudflare Pages](https://pages.cloudflare.com/), or [Netlify](https://www.netlify.com/).
> If you don't use pre-rendering, then you need to use a Node.js server to be able to render your pages' HTML at request-time.

To pre-render your pages, use the [CLI command `prerender`](#command-prerender) at the end of your build:
 - With npm: run `$ npx vite build && npx vite build --ssr && npx vite-plugin-ssr prerender`.
 - With Yarn: `$ yarn vite build && yarn vite build --ssr && yarn vite-plugin-ssr prerender`.

For pages with a parameterized route (e.g. `/movie/:movieId`), you have to use the [`prerender()` hook](#export--prerender-).

The `prerender()` hook can also be used to accelerate the pre-rendering process as it allows you to prefetch data for multiple pages at once.

Examples:
 - [/examples/vue/](examples/vue/)
 - [/examples/react/](examples/react/)

<br/><br/>


<h3>SPA vs SSR vs HTML</h3>

> :warning: We recommend reading the [Vue Tour](#vue-tour) or [React Tour](#react-tour) before proceeding with guides.

With `vite-plugin-ssr` you can create:
 - SSR pages
 - SPA pages (aka MPA)
 - HTML pages (with zero/minimal browser-side JavaScript)

For example, you can render your admin panel as SPA while rendering your marketing pages to HTML-only.

The rule of thumb is to render a page to:
 - HTML (zero/minimal browser-side JavaScript), if the page has no interactivity (technically speaking: if the page has no stateful component). Example: blog, non-interactive marketing pages.
 - SPA, if the page has interactivity and doesn't need SEO (e.g. the page doesn't need to appear on Google). Example: admin panel, desktop-like web app.
 - SSR, if the page has interactivity and needs SEO (the page needs to rank high on Google). Example: social news website, interactive marketing pages.

To render a page as SPA, simply render static HTML:

```js
// .page.server.js
// Environment: Node.js

import { html } from 'vite-plugin-ssr'

export function render() {
  // `div#app-root` is empty; the HTML is static.
  return html`<html>
    <head>
      <title>My Website</title>
    </head>
    <body>
      <div id="app-root"/>
    </body>
  </html>`
}
```

To render a page to HTML-only, define an empty `.page.client.js`:

```js
// .page.client.js
// Environment: Browser

// We leave this empty; there is no browser-side JavaScript.

// We can still include CSS
import './path/to/some.css'
```

<br/><br/>


### HTML `<head>`

> :warning: We recommend reading the [Vue Tour](#vue-tour) or [React Tour](#react-tour) before proceeding with guides.

HTML `<head>` tags such as `<title>` and `<meta>` are defined in the `render()` hook.

```js
// _default.page.server.js
// Environment: Node.js

import { html } from 'vite-plugin-ssr'
import { renderToHtml } from 'some-view-framework'

export { render }

async function render(pageContext) {
  return html`<html>
    <head>
      <title>SpaceX</title>
      <meta name="description" content="We deliver your payload to space.">
    </head>
    <body>
      <div id="root">
        ${html.dangerouslySkipEscape(await renderToHtml(pageContext.Page))}
      </div>
    </body>
  </html>`
}
```

If you want to define `<title>` and `<meta>` tags on a page-by-page basis, you can use `pageContext`.

```js
// _default.page.server.js

import { html } from 'vite-plugin-ssr'
import { renderToHtml } from 'some-view-framework'

export { render }

async function render(pageContext) {
  // We use `pageContext.documentProps` which pages define in their `addPageContext()` hook
  let title = pageContext.documentProps.title
  let description = pageContext.documentProps.description

  // Defaults
  title = title || 'SpaceX'
  description = description || 'We deliver your payload to space.'

  return html`<html>
    <head>
      <title>${title}</title>
      <meta name="description" content="${description}">
    </head>
    <body>
      <div id="root">
        ${html.dangerouslySkipEscape(await renderToHtml(pageContext.Page))}
      </div>
    </body>
  </html>`
}
```
```js
// about.page.server.js

export { addPageContext }

function addPageContext() {
  const documentProps = {
    // This title and description will override the defaults
    title: 'About SpaceX',
    description: 'Our mission is to explore the galaxy.'
  }
  return { documentProps }
}
```

If you want to define `<head>` tags by some deeply nested view component:
 1. Add `documentProps` to `passToClient`.
 2. Pass `pageContext.documentProps` [to all your components](#pass-pagecontext-to-anyall-components).
 3. Modify `pageContext.documentProps` in your deeply nested component.

```js
// _default.page.server.js
// Environment: Node.js

import { html } from 'vite-plugin-ssr'
import renderToHtml from 'some-view-framework'

export async function render(pageContext) {
  // Use your view framework to pass `pageContext.documentProps` to all components
  // of your component tree. (E.g. React Context or Vue's `app.config.globalProperties`.)
  const pageHtml = await renderToHtml(
    <ContextProvider documentProps={pageContext.documentProps} >
      <Page />
    </ContextProvider>
  )

  // What happens here is:
  // 1. Your view framework passed `documentProps` to all your components
  // 2. One of your (deeply nested) component modified `documentProps`
  // 3. You now render `documentProps` to HTML meta tags
  return html`<html>
    <head>
      <title>${pageContext.documentProps.title}</title>
      <meta name="description" content="${pageContext.documentProps.description}">
    </head>
    <body>
      <div id="app">
        ${html.dangerouslySkipEscape(pageHtml)}
      </div>
    </body>
  </html>`
}
```

```js
// Somewhere in a component deep inside your component tree

// Thanks to our previous steps, `documentProps` is available here.
documentProps.title = 'I was set by some deep component.'
documentProps.description = 'Me too.'
```

If you use Client-side Routing, make sure to update `document.title` upon page navigation.

```js
// _default.page.server.js

// We make `pageContext.documentProps` available in the browser.
export const passToClient = ['documentProps', 'pageProps']
```
```js
// _default.page.client.js

import { useClientRouter } from 'vite-plugin-ssr/client/router'

useClientRouter({
  render(pageContext) {
    if( ! pageContext.isHydration ) {
      document.title = pageContext.documentProps.title
    }
    // The usual stuff.
    // (Make sure to pass `pageContext.documentProps` to your whole component tree also here.)
    // ...
  }
})
```

You can also use libraries such as [@vueuse/head](https://github.com/vueuse/head) or [react-helmet](https://github.com/nfl/react-helmet)
but use such library only if you have a *strong* rationale:
the solution using `pageContext.documentProps` is considerably simpler and works for the vast majority of cases.

For pages defined with markdown, have a look at [Markdown `<head>`](#markdown-head).

<br/><br/>


### Page Redirection

> :warning: We recommend reading the [Vue Tour](#vue-tour) or [React Tour](#react-tour) before proceeding with guides.

Your `render()` hook doesn't have to return HTML and can, for example,
return an object such as `{ redirectTo: '/some/url' }`
which is then available at your server integration point `createPageRender()`
(you can then perform a URL redirect there).

```js
// movie.page.route.js
export default "/star-wars/:movieId";
```
```js
// movie.page.server.js
// Environment: Node.js

export { addPageContext }

function addPageContext(pageContext) {
  // If the user goes to `/movie/42` but there is no movie with ID `42` then
  // we redirect the user to `/movie/add` so he can add a new movie.
  if (pageContext.routeParams.movieId === null) {
    return { redirectTo: '/movie/add' }
  }
}
```
```js
// _default.page.server.js
// Environment: Node.js

export { render }

function render(pageContext) {
  const { redirectTo } = pageContext
  if (redirectTo) return { redirectTo }

  // The usual stuff
  // ...
}
```
```js
// server.js
// Environment: Node.js

const renderPage = createPageRender(/*...*/)

app.get('*', async (req, res, next) => {
  const url = req.originalUrl
  const pageContext = { url }
  const result = await renderPage(pageContext)
  if (result.nothingRendered) {
    return next()
  } else if (result.renderResult?.redirectTo) {
    res.redirect(307, '/movie/add')
  } else {
    res.status(result.statusCode).send(result.renderResult)
  }
})
```

If you use Client-side Routing, then also redirect at `*.page.client.js`.

```js
// movie.page.server.js
// Environment: Node.js

// We make `pageContext.redirectTo` available to the browser for Client-side Routing redirection
export const passToClient = ['redirectTo']
```
```js
// _default.page.client.js
// Environment: Browser

import { useClientRouter, navigate } from 'vite-plugin-ssr/client/router'

useClientRouter({
  render(pageContext) {
    const { redirectTo } = pageContext
    if (redirectTo) {
      navigate(redirectTo)
      return
    }

    // The usual stuff
    // ...
  }
})
```

<br/><br/>


### Base URL

> :warning: We recommend reading the [Vue Tour](#vue-tour) or [React Tour](#react-tour) before proceeding with guides.

The Base URL (aka Public Base Path) is about changing the URL root of your Vite app.
For example, instead of deploying your Vite app at `https://example.org` (i.e. `base: '/'`), you can set `base: '/some/nested/path/'` and deploy your Vite app at `https://example.org/some/nested/path/`.

Change Base URL for production:
1. Use Vite's [`--base` CLI build option](https://vitejs.dev/guide/build.html#public-base-path): `$ vite build --base=/some/nested/path/ && vite build --ssr --base=/some/nested/path/`. (For both `$ vite build` *and* `$ vite build --ssr`.)
2. If you don't pre-render your app: pass `base` to `createPageRender({ base: isProduction ? '/some/nested/path/' : '/' })`. (Pre-rendering automatically sets the right Base URL.)
3. Use the `import.meta.env.BASE_URL` value [injected by Vite](https://vitejs.dev/guide/build.html#public-base-path) to construct a `<Link href="/star-wars">` component that prepends the Base URL.

Change Base URL for local dev:
1. Pass `base` to `createServer({ base: '/some/nested/path/' })` (`import { createServer } from 'vite'`) and `createPageRender({ base: '/some/nested/path/' })` (`import { createPageRender } from 'vite-plugin-ssr'`).

You can also set `base: 'https://another-origin.example.org/'` (for cross-origin deployments) and `base: './'` (for embedded deployments at multiple paths).

Example:
 - [/examples/base-url/pages/_components/Link.jsx](examples/base-url/pages/_components/Link.jsx) (a `<Link>` component built on top of `import.meta.env.BASE_URL`)
 - [/examples/base-url/server/index.js](examples/base-url/server/index.js) (see the `base` option passed to `vite` and `vite-plugin-ssr`)
 - [/examples/base-url/package.json](examples/base-url/package.json) (see the build scripts)

<br/><br/>
