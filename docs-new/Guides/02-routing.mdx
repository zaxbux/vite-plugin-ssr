### Routing

> :warning: We recommend reading the [Vue Tour](#vue-tour) or [React Tour](#react-tour) before proceeding with guides.

 - [Server-side Routing VS Client-side Routing](#server-side-routing-vs-client-side-routing)
 - [Filesystem Routing VS Route Strings VS Route Functions](#filesystem-routing-vs-route-strings-vs-route-functions)
 - [Active Links `<a class="is-active">`](#active-links-a-classis-active)
 - [Nested Routes](#nested-routes)

<br/>

#### Server-side Routing VS Client-side Routing

You can choose between two routing strategy:
 - Server-side Routing (for simpler architecture)
 - Client-side Routing (for faster and animated page transitions)

You can also use a routing library such as Vue Router and React Router (in complete replacement or in combination). Examples:
 - [/examples/vue-router/](examples/vue-router/)
 - [/examples/react-router/](examples/react-router/)

By default, `vite-plugin-ssr` does Server-side Routing,
which is the "old school" way of doing routing: when the user changes the page,
a new HTML request is made, and the old page (i.e. its HTML) is completely replaced with the new page.

If you don't have a strong rationale for doing something differently, then stick to Server-side Routing as it leads to a simpler app architecture.

That said, `vite-plugin-ssr` has first-class support for Client-side Routing and you can opt-in by using `useClientRouter()`:
 - [`import { useClientRouter } from 'vite-plugin-ssr/client/router'`](#import--useClientRouter--from-vite-plugin-ssrclientrouter)

With Client-side Routing,
instead of doing a full HTML reload,
only the DOM is updated:
the new page's root (Vue/React/...) component is loaded and the view framework (Vue/React/...)
renders the new root component to the DOM.

Client-side Routing enables:
- Slightly faster page transitions.
- Custom animated page transitions.

But Client-side Routing leads to an inherently more complex app architecture,
which is why we recommend using Client-side Routing only if you
have a strong rationale.

<br/>

#### Filesystem Routing VS Route Strings VS Route Functions

If a page doesn't have a `.page.route.js` file then `vite-plugin-ssr` uses Filesystem Routing:

```
FILESYSTEM                  URL
pages/index.page.js         /
pages/about.page.js         /about
pages/faq/index.page.js     /faq
```

To define a parameterized route, or for more control, you can `export default` a Route String in `.page.route.js`.

```js
// /pages/product.page.route.js

export default '/product/:productId'
```

The `productId` value is available at `pageContext.routeParams.productId` so that you can fetch data in `async addPageContext(pageContext)` which is explained at [Data Fetching](#data-fetching).

For full programmatic flexibility, you can define a Route Function.

```js
// /pages/admin.page.route.js

// Route Functions allow us to implement advanced routing such as route guards.
export default (pageContext) => {
  const { url } = pageContext
  if (url === '/admin' && pageContext.user.isAdmin) {
    return { match: true }
  }
}
```

For detailed informations about Filesystem Routing, Route Strings, and Route Functions:
 - [API - Filesystem Routing](#filesystem-routing)
 - [API - `*.page.route.js`](#pageroutejs)
 - [API - Route String](#route-string)
 - [API - Route Function](#route-function)

<br/>

#### Active Links `<a class="is-active">`

Pass `pageContext.urlPathname` (available on both the client and the server)
[to your link component](#pass-pagecontext-to-anyall-components).
You can then set `isActive = href===urlPathname` in your link component.

<br/>

#### Nested Routes

A nested route (aka sub route) is, essentially, when you have a route with multiple parameters,
for example `/product/:productId/:productView`.

```
URL                        productId     productView
/product/1337              1337          null
/product/1337/pricing      1337          pricing
/product/42/reviews        42            reviews
```

With `vite-plugin-ssr`, we can define a Route String that has multiple parameters.

```js
// product.page.route.js

export default `/product/:productId/:productView`
```

```js
// product.page.route.js

// We can also use a Route Function
export default (pageContext) => {
  const { url } = pageContext
  if (! url.startsWith('/product/')) return false
  const [productId, productView] = url.split('/').slice(2)
  return { match: true, routeParams: { productId, productView } }
}
```

Usually, the sub route is used for navigating some (deeply) nested view:

```
/product/42/pricing                   /product/42/reviews
+------------------+                  +-----------------+
| Product          |                  | Product         |
| +--------------+ |                  | +-------------+ |
| | Pricing      | |  +------------>  | | Reviews     | |
| |              | |                  | |             | |
| +--------------+ |                  | +-------------+ |
+------------------+                  +-----------------+
```

> :warning: If your sub routes don't need URLs (if it's fine that the Product Pricing and the Product Reviews share the same URL `/product/42`), then you can simply use a stateful component instead. (When the user clicks on a "pricing" link => the stateful component changes its internal state `productView` to `'pricing'` to show the pricing view.)

By default,
`vite-plugin-ssr` does [Server-side Routing](#server-side-routing-vs-client-side-routing),
which means that when the user navigates from `/product/42/pricing` to `/product/42/reviews`,
the old page (i.e. the HTML of) `/product/42/pricing` is fully replaced with the new page (i.e. the HTML of) `/product/42/reviews`,
leading to a jittery experience.

For smoother navigations, we can use [Client-side Routing](#import--useClientRouter--from-vite-plugin-ssrclientrouter).

```js
// product.page.client.js

import { useClientRouter } from 'vite-plugin-ssr/client/router'

// We use Client-side Routing so that, when the user navigates from `/product/42/pricing`
// to `/product/42/reviews`, only the relevant (deeply) nested view is updated (instead of
// a full HTML reload).

// Note that we override `_default.page.client.js`. This means all our other pages can use
// Server-side Routing while this page uses Client-side Routing.
// (If we are already using `useClientRouter()` in `_default.page.client.js`, then we don't need to
// create this `product.page.client.js` file.)

useClientRouter({
  render(pageContext) {
    /* ... */
  }
})
```

We can then use `<a href="/product/42/reviews" keep-scroll-position />` / `navigate('/product/42/reviews', { keepScrollPosition: true })` to avoid the browser to scroll to the top upon navigation.

We can also [pass `pageContext.routeParams` to any/all components](#pass-pagecontext-to-anyall-components),
so that we can navigate/render the routed nested view.

Alternatively,
we can use a Route String Wildcard (e.g. `/product/:params*`) and then use a routing library (Vue Router, React Router, ...) for that page,
but we recommend the aforementioned solution instead as it is usually simpler.

<br/><br/>


